# 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，
# 问最后留下的是原来第几号的那位？


# 解法一：模拟法（适合理解原理）
# 我们可以用一个列表保存还在圈中的人，然后循环进行报数、删除操作，直到只剩一人。
def last_remaining(n):
    people = list(range(1, n + 1))  #初始化人员编号{1,2,...,n}
    index = 0  #当前报数位置

    while len(people) > 1:
        index = (index + 2) % len(people)  #报到3的位置
        #pop移除列表的一个元素
        people.pop(index)  #移除该人
    return people[0]

#测试：
print(last_remaining(100))  #输出最后留下的人的编号



'''
对于每次报数为 k=3 的情况，可以使用递推公式快速求出最后剩下的人的编号。

约瑟夫问题递推公式（k = 3）：
我们定义函数 f(n) 表示 n 个人时最后剩下人的编号（从 1 开始）：

f(1)=1
f(n)=(f(n−1)+3)%n  #如果结果为0，则取n
注意：这里的结果是从 1 开始编号的。
'''

# 解法二：数学公式法（高效解法）
def josephus(n):
    res = 0  #假设编号是从 0 开始的，最后再加 1 转换为 1-based 编号。
    for i in range(2, n + 1):  #从 2 个人开始，逐步增加到 n 个人:当只有 1 个人时，他就是幸存者，不需要计算！
        res = (res + 3) % i
    return res + 1

#测试：
print(josephus(100))