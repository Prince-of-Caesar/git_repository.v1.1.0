# 使用递归，可以绘制出非常复杂的图形。例如，下面的代码可以绘制一棵分型树：
from turtle import *

#设置色彩模式是RGB红绿蓝：
colormode(255)

# lt是left turn左转90度：
lt(90)

#定义了三个变量：lv(递归层次的最大值)、l(初始树枝长度)、s(转向角度)
lv = 14
l = 120
s =45

#设置画笔宽度为lv
width(lv)

#初始化RGB颜色值,并将画笔颜色设置为黑色
r = 0
g = 0
b = 0
pencolor(r, g, b)

#bk是backward向后移动的意思，拿起画笔向后移动l的距离，再放下画笔向前移动l
penup()
bk(l)
pendown()
fd(l)

#定义draw_tree函数接受两个参数：当前树枝长度l和当前递归层级level
def draw_tree(l, level):
    #声明全局变量
    global r, g, b
    #保存当前画笔宽度
    w = width()
    #将画笔宽度缩小到原来的3/4，模拟树枝分支变细的现象
    width(w * 3.0 / 4.0)

    #设置颜色
    #每次调用draw_tree时，rgb三个颜色分别增加1、2、3
    r = r + 1
    g = g +2
    b = b +3
    # 设置了新的画笔颜色。使用模运算（ %200）限制颜色值不超过200，这可以防止颜色值过大，并且创造了一个循环的颜色效果。
    pencolor(r % 200, g % 200, b % 200)

    #计算新长度并转向前进
    #当前树枝长度缩短至原来的3/4，模拟树枝分支变短的现象，左转45度，向前移动长度l
    l = 3.0 / 4.0 * l
    lt(s)
    fd(l)

    #递归绘制左侧子树
    #如果当前递归深度小于最大深度lv，则递归调用draw_tree绘制左侧子树
    #完成左侧子树绘制后，向后移动回到起点，右转两倍(90度)，然后再向前移动准备绘制右侧子树
    if level < lv:
        draw_tree(l, level + 1)
    bk(l)
    rt(2 * s)
    fd(l)

    #递归绘制右侧子树
    #类似地，如果当前递归深度小于最大深度，则递归调用draw_tree绘制右侧子树
    #绘制完成后，向后移动回到起点，左转45度
    if level < lv:
        draw_tree(l, level + 1)
    bk(l)
    lt(s)

    #在返回上一级递归调用之前，回复画笔的原始宽度，确保父级分支的绘制不受子分支画笔宽度变化的影响
    width(w)

#关闭动画
tracer(0)

#速度设置与开始绘制
#设置绘图速度为最快，然后从初始参数开始绘制分形树，最后调用done()保持窗口打开。
speed("fastest")
draw_tree(l, 4)
done()

#这段代码巧妙地结合了递归、条件判断、色彩变换和几何操作，创造出了一种自然且美观的分形树图案。